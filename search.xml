<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS原生实现bind以及apply和call]]></title>
    <url>%2F2019%2F09%2F08%2FJS%E5%8E%9F%E7%94%9F%E5%AE%9E%E7%8E%B0bind%E4%BB%A5%E5%8F%8Aapply%E5%92%8Ccall%2F</url>
    <content type="text"><![CDATA[面试题，没啥好说的 call call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 123456789var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.call(foo); // 1 两个点： call 改变了 this 的指向，指向到 foo bar 函数立即执行了 模拟实现第一步最简单的方法，给foo对象添加属性：12345678var foo = &#123; value: 1, bar: function() &#123; console.log(this.value) &#125;&#125;;foo.bar(); // 1 但这样会改变foo对象，所以我们需要在调用完删除这个属性。123456Function.prototype.call2 = function(context) &#123; // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn;&#125; 因为用完就删除，所以新定义的属性名就随意取了fn,这样我们的bind就有点那味了 模拟第二步1234567891011121314var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call(foo, 'kevin', 18);// kevin// 18// 1 如上所示，call还能接受参数执行函数，下面来实现这个特性。注意点： 参数数量和值均不确定 解决方案： 将arguments中除了第一个参数（this）以外的所有参数储存到新的数组中。 123456789101112131415161718192021222324Function.prototype.call2 = function(context) &#123; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; eval('context.fn(' + args +')'); delete context.fn;&#125;//由于arguments是类数组，此处将其转化为数组，并作为参数传给fnvar foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(name) console.log(age) console.log(this.value);&#125;bar.call2(foo, 'kevin', 18); // kevin// 18// 1 模拟第三步最后注意的两点： this 参数可以传 null，当为 null 的时候，视为指向 window 函数是可以有返回值的 12345678910111213141516171819202122232425262728293031323334353637383940Function.prototype.call2 = function (context) &#123; var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push('arguments[' + i + ']'); &#125; var result = eval('context.fn(' + args +')'); delete context.fn return result;&#125;// 测试一下var value = 2;var obj = &#123; value: 1&#125;function bar(name, age) &#123; console.log(this.value); return &#123; value: this.value, name: name, age: age &#125;&#125;bar.call2(null); // 2console.log(bar.call2(obj, 'kevin', 18));// 1// Object &#123;// value: 1,// name: 'kevin',// age: 18// &#125; apply原理和call差不多，只是传的参数形式不同，代码如下12345678910111213141516171819Function.prototype.apply = function (context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push('arr[' + i + ']'); &#125; result = eval('context.fn(' + args + ')') &#125; delete context.fn return result;&#125; bind bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。 首先举个例子：123456789101112var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1 第一步那么我们先写出第一版代码：123456789// 第一版Function.prototype.bind2 = function (context) &#123; var self = this; return function () &#123; return self.apply(context); //考虑到bind是有返回值的，所以写成这种形式 &#125;&#125; 第二步第二步，实现bind的传递参数，bind传递参数形式如下所示：12345678910111213141516var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, 'daisy');bindFoo('18');// 1// daisy// 18 可以看到，bind时只传入了name参数，而调用时又传递了age参数，这时我们就要用arguments进行处理了：1234567891011121314// 第二版Function.prototype.bind2 = function (context) &#123; var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () &#123; // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;&#125; 第三步完成了上面两步，现在到了最难的一部分。bind还有一个特点，就是： 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：12345678910111213141516171819202122232425var value = 2;var foo = &#123; value: 1&#125;;function bar(name, age) &#123; this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age);&#125;bar.prototype.friend = 'kevin';var bindFoo = bar.bind(foo, 'daisy');var obj = new bindFoo('18');// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin 尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下：12345678910111213141516// 第三版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); &#125; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125; 第四步但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：1234567891011121314151617// 第四版Function.prototype.bind2 = function (context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () &#123;&#125;; var fBound = function () &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125; 参考https://github.com/mqyqingfeng/Blog/issues/12]]></content>
      <tags>
        <tag>JS</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是傻逼]]></title>
    <url>%2F2019%2F09%2F08%2F%E6%88%91%E6%98%AF%E5%82%BB%E9%80%BC%2F</url>
    <content type="text"><![CDATA[纪念一下今天屁颠屁颠跑去北京面滴滴，然后一面被赶走的这件事情。]]></content>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件详解]]></title>
    <url>%2F2019%2F08%2F21%2FDOM%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[DOM 事件级别DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级。DOM 事件级别分为三个级别： DOM0 级事件12345678&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn') btn.onclick = function() &#123; console.log('Hello World') &#125; // btn.onclick = null // 解绑事件&lt;/script&gt; 缺点：无法设置多个事件处理函数 DOM2 级事件12345678910111213&lt;button id="btn" type="button"&gt;&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('btn'); btn.addEventListener('click', showFn, false) btn.addEventListener('click', showFn2, false) // btn.removeEventListener('click', showFn, false) // 解绑事件 function showFn() &#123; alert('Hello World'); &#125; function showFn2() &#123; alert('Hello World2'); &#125; &lt;/script&gt; 可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。 需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。 DOM3 级事件 DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 文本事件，当在文档中输入文本时触发，如：textInput 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart 变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified 1234567891011// 自定义事件var event = new Event('test')// 给元素绑定事件domElement.addEventListener('test', function() &#123; console.log('event test')&#125;,)// 触发事件setTimeout(function() &#123; domElement.dispatchEvent(event)&#125;, 1000) DOM 事件流 想象画在一张纸上的一组同心圆。如果把手指放在圆心上，那么手指指向的不仅仅是一个圆，而是纸上的所有圆。所以如果点击了某个按钮，点击事件不仅仅发生在这个按钮上，整个页面也被点击了。 事件流又称为事件传播，描述的是从页面中接收事件的顺序。DOM2 级事件规定事件流包括三个阶段: 事件捕获(capturing phase)、目标事件(target phase)、事件冒泡(bubbling phase)。 因为有两种观点，所以事件流也有两种，分别是事件冒泡和事件捕获。现行的主流是事件冒泡。 事件冒泡事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。举个栗子，就很容易明白了。 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Event Bubbling&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="clickMe"&gt;Click Me&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 然后，我们给button和它的父元素，加入点击事件。1234567891011121314var button = document.getElementById('clickMe');button.onclick = function() &#123; console.log('1. You click Button');&#125;;document.body.onclick = function() &#123; console.log('2. You click body');&#125;;document.onclick = function() &#123; console.log('3. You click document');&#125;;window.onclick = function() &#123; console.log('4. You click window');&#125;; 结果如下图所示：也就是说，click事件首先在button元素上发生，然后逐级向上传播。这就是事件冒泡。 事件捕获事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。比如说刚才的demo，如果是事件捕获的话，事件发生顺序会和上面相反。 当然，由于时代更迭，事件冒泡方式更胜一筹。所以放心的使用事件冒泡，有特殊需要再使用事件捕获即可。 addEventlistener在事件流中的运用addEventlistener的定义以及参数： 改用事件捕获模式例如，将上面的例子修改一下：123window.addEventListener('click', function() &#123; console.log('4. You click window');&#125;, true);//useCapture位设置为true，使用事件捕获模式 结果： 阻止事件冒泡再比如，事件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。这个方法就是:stopPropagation() 我们对button的click事件做一些改造：123456button.addEventListener('click', function(event) &#123; // event为事件对象 console.log('1. You click Button'); event.stopPropagation(); console.log('Stop Propagation!');&#125;, false); 结果如下：不难看出，事件在到达具体元素后，停止了冒泡。但不影响父元素的事件捕获。 参考https://juejin.im/post/5c4bd01fe51d45522b4f6e4e#heading-5https://segmentfault.com/a/1190000004463384]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[面试题]JS点击获取到ul下的li的index]]></title>
    <url>%2F2019%2F08%2F20%2F%E9%9D%A2%E8%AF%95%E9%A2%98-JS%E7%82%B9%E5%87%BB%E8%8E%B7%E5%8F%96%E5%88%B0ul%E4%B8%8B%E7%9A%84li%E7%9A%84index%2F</url>
    <content type="text"><![CDATA[面试题，不会，菜。 闭包12345678910111213141516var ul = document.getElementsByTagName("ul")[0]; var list = ul.getElementsByTagName("li"); function foo()&#123; for(var i = 0, len = list.length; i &lt; len; i++)&#123; var that = list[i]; list[i].onclick = (function(k)&#123; var info = that.innerHTML; return function()&#123; alert(k + "----" + info); &#125;; &#125;)(i); &#125; &#125; foo(); 事件代理12345678910111213var ul = document.querySelector('ul'); var list = document.querySelectorAll('ul li'); ul.addEventListener('click', function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElemnt; for(var i = 0, len = list.length; i &lt; len; i++)&#123; if(list[i] == target)&#123; alert(i + "----" + target.innerHTML); &#125; &#125; &#125;); JQuery123456789101112// delegate方法$("ul").delegate("li", "click", function()&#123; var index = $(this).index(); var info = $(this).html(); alert(index + "----" + info); &#125;); // on方法$("ul").on("click", "li", function()&#123; var index = $(this).index(); var info = $(this).html(); alert(index + "----" + info); &#125;); ES6 let1234567891011var ul = document.getElementsByTagName("ul")[0]; var list = ul.getElementsByTagName("li"); function foo()&#123;'use strict' for(let i = 0, len = list.length; i &lt; len; i++)&#123; list[i].onclick = function()&#123; alert(i + "----" + this.innerHTML); &#125; &#125; &#125; foo(); 参考https://segmentfault.com/q/1010000008557139]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数防抖和节流]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[函数防抖(debounce) 概念:在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 实现思路如下，将目标方法（动作）包装在setTimeout里面，然后这个方法是一个事件的回调函数，如果这个回调一直执行，那么这些动作就一直不执行。为什么不执行呢，我们搞了一个clearTimeout，这样setTimeout里的方法就不会执行！ 为什么要clearTimeout呢，我们就需要将事件内的连续动作删掉嘛！待到用户不触发这事件了，那么setTimeout就自然会执行这个方法。 12345678910//模拟一段ajax请求function ajax(content) &#123; console.log('ajax request ' + content)&#125;let inputa = document.getElementById('unDebounce')inputa.addEventListener('keyup', function (e) &#123; ajax(e.target.value)&#125;) 效果如下：可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：1234567891011121314151617181920212223//模拟一段ajax请求function ajax(content) &#123; console.log('ajax request ' + content)&#125;function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125; let inputb = document.getElementById('debounce')let debounceAjax = debounce(ajax, 500)inputb.addEventListener('keyup', function (e) &#123; debounceAjax(e.target.value) &#125;) 效果：加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 1234567891011let biu = function () &#123; console.log('biu biu biu',new Date().Format('HH:mm:ss'))&#125;let boom = function () &#123; console.log('boom boom boom',new Date().Format('HH:mm:ss'))&#125;setInterval(debounce(biu,500),1000)setInterval(debounce(boom,2000),1000) 运行结果：如果在时间间隔内执行函数，会重新触发计时。biu会在第一次1.5s执行后，每隔1s执行一次，而boom一次也不会执行。因为它的时间间隔是2s，而执行时间是1s，所以每次都会重新触发计时。 防抖就像技能的GCD(公共冷却时间),正在转gcd的时候再次释放了技能就又要重新计时。 将debounce抽离出来并简化写法:123456789101112function debounce(fun, delay) &#123; var timer; return function()&#123; let that = this; let args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fun.apply(that,args) &#125;,delay) &#125; &#125; 函数节流(throttle) 概念:规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 方法一：使用时间戳当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为0)，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 缺陷：第一次事件会立即执行，停止触发后没办法再激活事件。12345678910111213function throttle(fn, interval) &#123; var previousTime = +new Date() return function () &#123; var that = this var args = arguments var now = +new Date() if (now - previousTime &gt;= interval) &#123; previousTime = now fn.apply(that, args) &#125; &#125;&#125; 方法二：使用定时器当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 缺陷：第一次事件会在n秒后执行，停止触发后依然会再执行一次事件。1234567891011121314function throttle(fn, interval) &#123; var timer return function ()&#123; var that = this var args = arguments if(!timer)&#123; timer = setTimeout(function () &#123; fn.apply(that, args) timer = null &#125;, interval) &#125; &#125;&#125; 方法三：优化鼠标移入能立刻执行，停止触发的时候还能再执行一次。12345678910111213141516171819var throttle = function(func,delay)&#123; var timer = null; var startTime = Date.now(); return function()&#123; var curTime = Date.now(); var remaining = delay-(curTime-startTime); var context = this; var args = arguments; clearTimeout(timer); if(remaining&lt;=0)&#123; func.apply(context,args); startTime = Date.now(); &#125;else&#123; timer = setTimeout(func,remaining); &#125; &#125;&#125; 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 应用场景 debounce search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 参考https://zhuanlan.zhihu.com/p/38313717https://juejin.im/post/5b8de829f265da43623c4261]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个判断数据类型的函数及其原理]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[typeoftypeof:返回基本类型，即 “number”，”string”，”undefined”，”boolean”，”object” 五种，对于数组和对象来说，typeof统统返回”object” 1234567typeof(undefind)//undefind typeof(123)//numbertypeof("abc")//stringtypeof("[]")//objecttypeof("&#123;&#125;")//objecttypeof(null)//objecttypeof(()=&gt;&#123;&#125;)//function js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息: 000：对象 010：浮点数 100：字符串 110：布尔 1：整数 但是，对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 null：所有机器码均为0 undefined：用 −2^30 整数来表示 所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。 instanceofinstanceof:判断复合类型和正则表达式，返回true和false，但是不能判断基本数据类型 12345678910111213141516171819202122var a = &#123;&#125;;var b = [];var c = function () &#123;&#125;; //a b c 都是 Object 的实例console.log(a instanceof Object) //trueconsole.log(b instanceof Object) //trueconsole.log(c instanceof Object) //true //只有 Array 类型的 b 才是 Array 的实例console.log(a instanceof Array) //falseconsole.log(b instanceof Array) //trueconsole.log(c instanceof Array) //false //只有 Function 类型的 c 才是 Function 的实例console.log(a instanceof Function) //falseconsole.log(b instanceof Function) //falseconsole.log(c instanceof Function) //trueconsole.log(/\d/ instanceof RegExp);//trueconsole.log('' instanceof String);//falseconsole.log(1 instanceof Number);//false 可以凑合着用来准确地判断对象的复合类型： 123456//对象(a instanceof Object) &amp;&amp; !(a instanceof Function) &amp;&amp; !(a instanceof Function)//数组(a instanceof Object) &amp;&amp; (a instanceof Array)//函数(a instanceof Object) &amp;&amp; (a instanceof Function) 具体实现过程就是向上遍历原型链，实现代码：123456789101112function _instanceof(A, B) &#123; var O = B.prototype;// 取B的显示原型 A = A.__proto__;// 取A的隐式原型 while (true) &#123; //Object.prototype.__proto__ === null if (A === null) return false; if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true return true; A = A.__proto__; &#125;&#125; Object.prototype.toString.call()最好用的判断复合类型方法还是使用Object.prototype.toString.call()这个函数： 123456789console.log(Object.prototype.toString.call(123)) //[object Number]console.log(Object.prototype.toString.call('abc')) //[object String]console.log(Object.prototype.toString.call(undefined)) //[object Undefined]console.log(Object.prototype.toString.call(null)) //[object Null]console.log(Object.prototype.toString.call(true)) //[object Boolean]console.log(Object.prototype.toString.call(Symbol(1))) //[object Symbol]console.log(Object.prototype.toString.call(&#123;&#125;)) //[object Object]console.log(Object.prototype.toString.call([])) //[object Array]console.log(Object.prototype.toString.call(function()&#123;&#125;)) //[object Function] 可以看到，它能够区分所有的数据类型。（ES6 还能区分map和set）原理：Object.prototype.toString()在toString方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 返回三个字符串”[object “, class, 以及 “]”连接后的新字符串. [[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的 然后给了一段解释：所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值. [[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值. 原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”. 不过ES6 后[[class]]内部属性被删除，取而代之的是另一个内部属性[[NativeBrand]],该属性的定义如下：[[NativeBrand]]内部属性的解释：[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName. [[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在下表中明确指出的对象类型才有[[NativeBrand]]内部属性. 可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]]。 同时,Object.prototype.toString方法的规范也改成了下面这样: 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值. 否则 让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag. 如果hasTag为false,则让tag为”Object”. 否则, 让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag. 如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”). 让tag成为tag.[[value]]. 如果Type(tag)不是字符串,则让tag成为”???”. 如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果. 返回三个字符串”[object “, tag, and “]”连接后的新字符串. 参考https://blog.csdn.net/u011374890/article/details/50325323https://juejin.im/post/5b7f64be51882542c83476f0https://juejin.im/post/5b0b9b9051882515773ae714https://www.cnblogs.com/ziyunfei/archive/2012/11/05/2754156.html]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中的类与继承]]></title>
    <url>%2F2019%2F08%2F15%2FES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[ES6前的类和继承可以参考下这篇文章JavaScript常用八种继承方案，修改原型链的操作真是令人脑阔痛. 类传统的ES5 类定义： 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); ES6 中加入了class关键字，使得类的原型写法更加清晰，更像面对对象编程的语法。 12345678910class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 其中的constructor就是类的构造方法，this代表了实例对象，也就是说ES5 的构造函数Point对应了ES6 中的Point类的构造方法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 继承举个例子:12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; super在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。 12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 1234let cp = new ColorPoint(25, 8, &apos;green&apos;);cp instanceof ColorPoint // truecp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 最后，父类的静态方法，也会被子类继承。12345678910class A &#123; static hello() &#123; console.log(&apos;hello world&apos;); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world 参考http://es6.ruanyifeng.com/#docs/class-extends]]></content>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts中toolbox的自定义工具]]></title>
    <url>%2F2019%2F08%2F12%2Fecharts%E4%B8%ADtoolbox%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[做excel2echarts项目的时候遇到的一个问题，当时还困扰了我好久都没做出满意的效果，最后在师傅的指点下顺利地完成了,也参考了挺多资料，所以记录一下。 效果最后实现的效果是这样的，点击按钮能切换label的显示与隐藏状态： 参考代码1234567891011121314151617181920212223242526toolbox: &#123; feature: &#123; dataView: &#123;show: true, readOnly: false&#125;, restore: &#123;show: true&#125;, saveAsImage: &#123;show: true&#125;, myTool1: &#123; show: true, title: '标签显示', icon: 'path://M432.45,595.444c0,2.177-4.661,6.82-11.305,6.82c-6.475,0-11.306-4.567-11.306-6.82s4.852-6.812,11.306-6.812C427.841,588.632,432.452,593.191,432.45,595.444L432.45,595.444z M421.155,589.876c-3.009,0-5.448,2.495-5.448,5.572s2.439,5.572,5.448,5.572c3.01,0,5.449-2.495,5.449-5.572C426.604,592.371,424.165,589.876,421.155,589.876L421.155,589.876z M421.146,591.891c-1.916,0-3.47,1.589-3.47,3.549c0,1.959,1.554,3.548,3.47,3.548s3.469-1.589,3.469-3.548C424.614,593.479,423.062,591.891,421.146,591.891L421.146,591.891zM421.146,591.891', onclick: function(a, obj) &#123; var op = obj.getOption(); var tmpSerise = []; for (var i = 0; i &lt; op.series.length; i++) &#123; op.series[i].label.show = !op.series[i].label.show; op.series[i].labelLine.show = !op.series[i].labelLine.show; tmpSerise.push(op.series[i]); &#125; that.chart.setOption(&#123; series:tmpSerise &#125;); &#125; &#125;, &#125;&#125;, 解析echarts配置详情参考官方文档，此处就不再赘述toolbox.feature中的前几项：dataView，saveAsImage等都是官方自带的工具，只要设置其属性为show:true即可使用。 自定义工具必须以my开头，这里我定义为myTool1。 工具内函数onclick触发setOption,将echarts图表的option.series[i].label.show，也就是所有数据的标签取反，从而实现显示隐藏标签。 但问题来了，我的echarts图表当初声明的时候为了调用方便，使用的写法是这样的：1this.chart = echarts.init(document.getElementById(this.id)) 我将echarts赋值给了vue全局的chart属性，在外边都是直接通过this.chart直接访问的，而toolbox里的函数调用this的话是指向toolbox内部的（具体是哪个我忘了），获取不到整个chart，无法实现setoption更新数据。 这咋整呢，我第一反应是找方法能让子函数获取到父函数属性，折腾了半天都没成功（也不知道为啥）。 另一种方法是onclick不触发函数，直接写个箭头函数，手动把this.chart的里面所有的series的label.show属性全取反，但这样写出来的代码又臭又长，而且变通性差，数据series个数不一样就会报错。 最后还是老老实实去请教了师傅，师傅拉开控制台一顿输出，看了下onclick接收的参数居然有4个（我好蠢） 而其中的第二个参数是api列表，其中的getOption可以直接获取到chart的option， 然后再在声明echarts的代码下加一句：12this.chart = echarts.init(document.getElementById(this.id)) var that = this; 这样就可以在onclick函数中使用that.chart.setOption来更新chart图表的option啦~真是简单呢（爪巴]]></content>
      <tags>
        <tag>前端</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线读取excel文件并生成echarts图表小工具]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%9C%A8%E7%BA%BF%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6%E5%B9%B6%E7%94%9F%E6%88%90echarts%E5%9B%BE%E8%A1%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[实习期间做得第一个小项目，也算是第一个自己从头到尾独立完成的项目吧，写个博客记录一下，也方便以后的参考。 使用的vue.cli搭建的基础框架，然后前端界面大部分使用了element，技术核心的库一个是echarts另一个是js-xlsx，大概就这些。 项目的github地址。 运行方式1234git clone https://github.com/PYHerman/excel2echarts.gitcd excel2echartsyarn install yarn run serve 由于没挂服务器，所以暂不支持在线使用，另外由于项目中的数据涉及到公司的业务信息，就不提供具体数据模板了。 项目结构 主要内容都在src文件夹下，其他都是脚手架生产的文件和配置文件等 src/App.vue 程序的整体页面布局 src/main.js 程序的全局调用的库以及页面路由 src/assets 储存静态资源，如图片，参考excel文件等 src/components 储存程序的各个vue组件 其中map、line和bar分别对应了地图，线柱图和饼图。upload组件是直接拿的vue-element-admin里的上传excel直接改的，我把这个组件分别嵌入了三个图表组件中，以实现不借助后端同页面前端数据传输的效果 内部技术主要思想就是通过xlsx库读取上传的excel文件，提取出内部的表格数据，然后储存成json格式，通过vue的绑定监听上传成功的回调函数，再调用echarts的setOption更新图表 这项目当时师傅主要是想让我熟悉下vue项目的构建，也没啥很难的东西，而且我后面还想继续优化这项目使得读取文件什么的能够更加智能方便吧，现在数据处理这块还是写死的，限定了excel里的表头格式，详情请见项目页面的向导页， 所以先挖个坑，以后有机会就填]]></content>
      <tags>
        <tag>前端</tag>
        <tag>个人项目</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo如何加入自定义live2d吉祥物]]></title>
    <url>%2F2019%2F08%2F10%2Fhexo%E5%A6%82%E4%BD%95%E5%8A%A0%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89live2d%E5%90%89%E7%A5%A5%E7%89%A9%2F</url>
    <content type="text"><![CDATA[忙活了几个钟头，终于把这吉祥物给安上了，把心路历程写一下。 先放上live2d组件的github原地址。 最简单的方法，可以直接在 themes/next(your themes&#39; name)/layout/_layout.swig 中加入这三行代码 123&lt;script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"&gt;&lt;script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"&gt;&lt;/script&gt; 你的博客里就会自动出现默认样式的live2d人物啦。 如图所示，默认样式固定在左边，可能会遮挡内容 不过不能修改肯定是不行的，比如大小，位置还有台词等。对于hexo有两种自定义方法： 推荐方法 fork原作者project，然后自己修改属性，再调用jsdelivr上的cdn来部署 github上选择download zip下载源文件，解压到博客的./source/文件夹下，通过绝对路径部署 两种方法没什么区别，要改的东西都一样，既live2d-widget/autoload.js的第一行中的live2d_path的值，该值代表了博客部署后，live2d-widget文件夹的绝对路径。 123//注意：live2d_path参数应使用绝对路径const live2d_path = "https://cdn.jsdelivr.net/gh/PYHerman/live2d-widget/";//const live2d_path = "/live2d-widget/"; 一开始我感觉导入本地肯定是修改起来更方便的，于是按部就班地储存文件，修改绝对路径，git push，但是没有生效。。。在一番搜索和瞎鸡儿修改之后，我放弃了。 于是我开始着手另一种方法，先fork项目，再pull下来在本地修改后再传上去（组件的css属性在waifu.css里修改），一番鼓捣后再hexo s -g ，又发现live2d的样式没有变化。 我跑到对应的jsdelivr界面一看 （地址：https://cdn.jsdelivr.net/gh/username/live2d-widget/ username为你的用户名）发现里面只储存了之前的版本的仓库，它是根据仓库的tag版本自动更新的。 于是在github仓库里找到你最新修改提交的commit编号 在命令行里敲12git flag v0.6.0 1cecdc7git push origin v0.6.0 这样这个tag就上传到了github,等待一小会，jsdelivr中对应界面就会更新，然后将_layout.swig中对应的引入cdn的代码中的地址加上@0.6.01&lt;script src="https://cdn.jsdelivr.net/gh/pyherman/live2d-widget@0.6.0/autoload.js"&gt;&lt;/script&gt; 这样就大功告成拉，这之后自己修改live2d组件也方便了许多。 顺带一提，可以将live2d组件单独创建一个live2d.swig文件，123&#123;% if theme.live2d %&#125; &lt;script src="https://cdn.jsdelivr.net/gh/pyherman/live2d-widget@0.6.0/autoload.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 然后在_layout.swig中加入 在博客中加入这行代码居然会报错hhh，以后要注意了 最后在对应的themes文件夹下的配置文件_config.yml中加入属性live2d: true。这样live2d也写成一个组件，提高了代码复用性，显示隐藏也方便了许多~]]></content>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写点什么]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[终于考完了并行计算，可以好好学习了（？） 于是搞了下blog 没啥想写的，给自己加个油8 希望今年秋天能找到一个好点的实习（您配嘛？]]></content>
      <tags>
        <tag>吐槽</tag>
      </tags>
  </entry>
</search>
